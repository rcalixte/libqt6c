// qrc-c compiles a Qt resource XML file (*.qrc) to an include header and
// creates a C header stub to load it.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
)

const (
	DefaultVariableName string = "_resource_rcc_"
	DefaultUpper        bool   = false
)

var DefaultRccBinary string = "rcc"

func QrcExec() error {
	// Parse arguments
	var inFile, outH, varName, rccPath string
	var upper bool

	inUsage := "Path to .qrc input file"
	outHUsage := "(Optional) Path to .h output file; if omitted, inferred from the input file path"
	varNameUsage := "(Optional) Variable name for loading embedded data; if omitted, inferred from the input file path"
	rccUsage := "(Optional) Custom path to the Qt 'rcc' program"
	upperUsage := "(Optional) Use uppercase hex letters, defaults to false"
	shorthandUsage := " (shorthand)"

	flag.StringVar(&inFile, "input_file", "", inUsage)
	flag.StringVar(&inFile, "i", "", inUsage+shorthandUsage)
	flag.StringVar(&outH, "output_header", "", outHUsage)
	flag.StringVar(&outH, "o", "", outHUsage+shorthandUsage)
	flag.StringVar(&varName, "variable_name", "", varNameUsage)
	flag.StringVar(&varName, "v", "", varNameUsage+shorthandUsage)
	flag.StringVar(&rccPath, "rcc_path", DefaultRccBinary, rccUsage)
	flag.StringVar(&rccPath, "r", DefaultRccBinary, rccUsage+shorthandUsage)
	flag.BoolVar(&upper, "uppercase", DefaultUpper, upperUsage)
	flag.BoolVar(&upper, "u", DefaultUpper, upperUsage+shorthandUsage)
	flag.Parse()

	if inFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Check if input file exists
	if _, err := os.Stat(inFile); os.IsNotExist(err) {
		return fmt.Errorf("input file '%s' not found", inFile)
	}

	// Figure out regeneration command and fill in default output names, if not specified
	generate := "qrc-c" + " -i " + strconv.Quote(inFile)

	if outH != "" && strings.HasSuffix(outH, ".h") {
		if strings.HasPrefix(outH, ".") {
			generate += " -o " + strconv.Quote(outH)
		} else {
			generate += " -o " + strconv.Quote(filepath.Base(outH))
		}
	} else {
		outH = strings.TrimSuffix(inFile, ".qrc") + ".h"
	}

	outRcc := strings.TrimSuffix(outH, ".h") + ".rcc"

	switch varName {
	case "":
		varName = DefaultVariableName + strings.TrimSuffix(filepath.Base(inFile), ".qrc") + "_data"
	default:
		generate += " -v " + strconv.Quote(varName)
	}

	if upper {
		generate += " -u"
	}

	if rccPath != DefaultRccBinary {
		generate += " -r " + strconv.Quote(rccPath)
	}

	// Compile qrc to binary resource file
	rccCmd := exec.Command(rccPath, "--binary", "-o", outRcc, inFile)
	rccCmd.Stderr = os.Stderr
	rccCmd.Stdout = os.Stdout
	errRcc := rccCmd.Run()
	if errRcc != nil {
		return errRcc
	}

	// Convert the binary resource file to string data
	rccBinary, err := os.ReadFile(outRcc)
	if err != nil {
		return err
	}

	rccToStr := strings.Builder{}
	rccToStr.WriteString(`// Generated by libqt6c qrc. To update this file, edit the .qrc file in
// Qt Creator/Designer and then run the 'qrc-c' command below.
//
// ` + generate + `

#include <libqt6c.h>

`)

	rccReader := bytes.NewReader(rccBinary)

	if err = xxd(rccReader, &rccToStr, varName, upper); err != nil {
		return err
	}

	methodName := strings.Trim(varName, "_")

	// Create methods to register and unregister the resource
	rccToStr.WriteString(`
bool qrc_` + methodName + `_init() {
    return q_resource_register_resource2(&` + varName + `[0]);
}

bool qrc_` + methodName + `_delete() {
    return q_resource_unregister_resource2(&` + varName + `[0]);
}
`)

	if err = os.WriteFile(outH, []byte(rccToStr.String()), 0644); err != nil {
		return fmt.Errorf("error writing to '%s': %w", outH, err)
	}
	if err = os.Remove(outRcc); err != nil {
		return err
	}

	return nil
}

func main() {
	switch runtime.GOOS {
	case "darwin":
		DefaultRccBinary = "/opt/homebrew/share/qt/libexec/rcc"
	case "freebsd":
		DefaultRccBinary = "/usr/local/libexec/qt6/rcc"
	case "windows":
		DefaultRccBinary = "C:\\Qt\\6.8.3\\llvm-mingw_64\\bin\\rcc.exe"
	}

	err := QrcExec()
	if err != nil {
		fmt.Fprintf(os.Stderr, "qrc-c: %s\n", err.Error())
		os.Exit(1)
	}
}
